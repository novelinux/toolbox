# iozone

## Test Cases

* Write:

测试向一个新文件写入的性能。当一个新文件被写入时，不仅仅是那些文件中的数据需要被存储，
还包括那些用于定位数据存储在存储介质的具体位置的额外信息。这些额外信息被称作“元数据”。
它包括目录信息，所分配的空间和一些与该文件有关但又并非该文件所含数据的其他数据。拜这些
额外信息所赐，Write的性能通常会比Re-write的性能低。

* Re-write:

测试向一个已存在的文件写入的性能。当一个已存在的文件被写入时，所需工作量较少，因为此时
元数据已经存在。Re-write的性能通常比Write的性能高。

* Read:

测试读一个已存在的文件的性能。

* Re-Read:

测试读一个最 近读过的文件的性能。Re-Read性能会高些，因为操作系统通常会缓存最
近读过的文件数据。这个缓存可以被用于读以提高性能。

* Random Read:

测试读一个文件中的随机偏移量的性能。许多因素都可能影响这种情况下的系统性能，
例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。

* Random Write:

测试写一个文件中的随机偏移量的性能。同样，有许多因素可能影响这种情况下的系统性能，
例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。

* Random Mix:

测试读写一个文件中的随机偏移量的性能。许多因素可能影响这种情况下的系统性能运作，
例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。这个测试只有在吞吐量测试模式下
才能进行。每个线程/进程运行读或写测试。这种分布式读/写测试是基于round robin 模式的。
最好使用多于一个线程/进程执行此测试。

* Backwards Read:

测试使用倒序读一个文件的性能。这种读文件方法可能看起来很可笑，事实上，有些应用确实这么干。
MSC Nastran是一个使用倒序读文件的应用程序的一个例子。它所读的文件都十分大（大小从G级别到T级别）。
尽管许多操作系统使用一些特殊实现来优化顺序读文件的速度，很少有操作系统注意到并增强倒序读文件的性能。
Record Rewrite: 测试写与覆盖写一个文件中的特定块的性能。这个块可能会发生一些很有趣的事。如果这个
块足够小（比CPU数据缓存小），测出来的性能将会非常高。如果比CPU数据缓存大而比TLB小，测出来的是
另一个阶段的性能。如果比此二者都大，但比操作系统缓存小，得到的性能又是一个阶段。若大到超过操作系统
缓存，又是另一番结果。

* Strided Read:

测试跳跃读一个文件的性能。举例如下：在0偏移量处读4Kbytes，然后间隔200Kbytes,读4Kbytes，
再间隔200Kbytes，如此反复。此时的模式是读4Kbytes，间隔200Kbytes并重复这个模式。这又是
一个典型的应用行为，文件中使用了数据结构并且访问这个数据结构的特定区域的应用程序常常这样做。
许多操作系统并没注意到这种行为或者针对这种类型的访问做一些优化。同样，这种访问行为也可能导致
一些有趣的性能异常。一个例子是在一个数据片化的文件系统里，应用程序的跳跃导致某一个特定的磁盘
成为性能瓶颈。

* Fwrite:

测试调用库函数fwrite()来写文件的性能。这是一个执行缓存与阻塞写操作的库例程。缓存在用户空间之内。
如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用
并在操作系统调用时增加传输块的大小来增强应用程序的性能。
这个测试是写一个新文件，所以元数据的写入也是要的。

* Frewrite:

测试调用库函数fwrite()来写文件的性能。这也是一个执行缓存与阻塞写操作的库例程。是缓存在
用户空间之内。如果一个应用程序想要写很小的传输块，fwrite()函数中的缓存与阻塞I/O功能可以
通过减少实际操作系统调用并在操作系统调用时增加传输块的大小来增强应用程序的性能。
这个测试是写入一个已存在的文件，由于无元数据操作，测试的性能会高些。

* Fread:

测试调用库函数fread()来读文件的性能。这是一个执行缓存与阻塞读操作的库例程。缓存在用户空间之内。
如果一个应用程序想要读很小的传输块，fwrite()函数中的缓存与阻塞I/O功能能通过减少实际操作系统调用
并在操作系统调用时增加传输块的大小从而增强应用程序的性能。

几个特殊测试:

* Mmap:

许多操作系统支持mmap()的使用来映射一个文件到用户地址空间。映射之后,对内存的读写将同步到文件中去。
这对一些希望将文件当作内存块来使用的应用程序来说很方便。一个例子是内存中的一块将同时作为一个文件
保存在于文件系统中。